<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>
    <script>
      let nextUnitOfWork = null;
      let wipRoot = null;
      let currentRoot = null;
      let deletions = null;
      const isGone = (pre, next) => (key) => !Reflect.has(next, key);
      const isNew = (prev, next) => (key) => prev[key] !== next[key];
      const isEvent = (key) => key.startsWith("on");
      const isProperty = (key) => key !== "children" && !isEvent(key);
      const createTextElement = (text) => {
        return {
          type: "TEXT_ELEMENT",
          props: {
            nodeValue: text,
            children: [],
          },
        };
      };
      const createElement = (type, props, ...children) => {
        return {
          type,
          props: {
            ...props,
            children: children.map((child) => {
              return typeof child === "object"
                ? child
                : createTextElement(child);
            }),
          },
        };
      };
      const createDom = (fiber) => {
        const dom =
          fiber.type === "TEXT_ELEMENT"
            ? document.createTextNode(fiber.props.nodeValue)
            : document.createElement(fiber.type);

        updateDom(dom, {}, fiber.props);

        return dom;
      };
      const updateDom = (dom, preProps, nextProps) => {
        Reflect.ownKeys(preProps)
          .filter(isEvent)
          .filter(
            (key) =>
              !Reflect.has(nextProps, key) || isNew(preProps, nextProps)(key)
          )
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2);
            dom.removeEventListener(eventType, preProps[name]);
          });

        Reflect.ownKeys(preProps)
          .filter(isProperty)
          .filter(isGone(preProps, nextProps))
          .forEach((name) => {
            dom[name] = "";
          });

        Reflect.ownKeys(nextProps)
          .filter(isProperty)
          .filter(isNew(preProps, nextProps))
          .forEach((name) => {
            dom[name] = nextProps[name];
          });

        Reflect.ownKeys(nextProps)
          .filter(isEvent)
          .filter(isNew(preProps, nextProps))
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2);
            dom.addEventListener(eventType, nextProps[name]);
          });
      };
      const commitDeletion = (fiber, domParent) => {
        if (fiber.dom) {
          domParent.removeChild(fiber.dom);
        } else {
          commitDeletion(fiber.child, domParent);
        }
      };
      const commitWork = (fiber) => {
        if (!fiber) {
          return;
        }
        let domParentFiber = fiber.parent;
        while (!domParentFiber.dom) {
          domParentFiber = domParentFiber.parent;
        }
        const domParent = domParentFiber.dom;
        if (fiber.effectTag === "PLACEMENT" && fiber.dom !== null) {
          domParent.appendChild(fiber.dom);
        }
        if (fiber.effectTag === "DELETION" && fiber.dom !== null) {
          commitDeletion(fiber, domParent);
        }
        if (fiber.effectTag === "UPDATE" && fiber.dom !== null) {
          updateDom(fiber.dom, fiber.alternate.props, fiber.props);
        }

        commitWork(fiber.child);
        commitWork(fiber.sibling);
      };
      const commitRoot = () => {
        deletions.forEach(commitWork);
        commitWork(wipRoot.child);
        currentRoot = wipRoot;
        wipRoot = null;
      };
      const render = (element, container) => {
        wipRoot = {
          dom: container,
          props: {
            children: [element],
          },
          alternate: currentRoot,
        };
        deletions = [];
        nextUnitOfWork = wipRoot;
      };
      const reconcileChildren = (wipFiber, elements) => {
        let index = 0;
        let oldFiber = wipFiber.alternate && wipFiber.alternate.child;

        let preSibling = null;
        while (index < elements.length || oldFiber !== null) {
          const element = elements[index];
          let newFiber = null;
          const sameType =
            oldFiber && element && element.type === oldFiber.type;
          if (sameType) {
            newFiber = {
              type: oldFiber.type,
              props: element.props,
              dom: oldFiber.dom,
              parent: wipFiber,
              alternate: oldFiber,
              effectTag: "UPDATE",
            };
          }

          if (element && !sameType) {
            newFiber = {
              type: element.type,
              props: element.props,
              dom: null,
              parent: wipFiber,
              alternate: null,
              effectTag: "PLACEMENT",
            };
          }

          if (oldFiber && !sameType) {
            oldFiber.effectTag = "DELETION";
            deletions.push(oldFiber);
          }

          if (oldFiber) {
            oldFiber = oldFiber.sibling;
          }
          if (index === 0) {
            wipFiber.child = newFiber;
          } else {
            preSibling.sibling = newFiber;
          }
          preSibling = newFiber;
          index++;
        }
      };
      const updateFunctionComponent = (fiber) => {
        const children = [fiber.type(fiber.props)];
        reconcileChildren(fiber, children);
      };
      const updateHostComponent = (fiber) => {
        if (!fiber.dom) {
          fiber.dom = createDom(fiber);
        }
        reconcileChildren(fiber, fiber.props.children);
      };
      const performUnitOfWork = (fiber) => {
        const isFunctionComponent = fiber.type instanceof Function;
        if (isFunctionComponent) {
          updateFunctionComponent(fiber);
        } else {
          updateHostComponent(fiber);
        }

        if (fiber.child) {
          return fiber.child;
        }
        let nextFiber = fiber;
        while (nextFiber) {
          if (nextFiber.sibling) {
            return nextFiber.sibling;
          }
          nextFiber = nextFiber.parent;
        }
      };
      const workLoop = (deadLine) => {
        let showYield = false;
        while (nextUnitOfWork && !showYield) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          showYield = deadLine.timeRemaining() < 1;
        }
        if (!nextUnitOfWork && wipRoot) {
          commitRoot();
        }
        requestIdleCallback(workLoop);
      };
      requestIdleCallback(workLoop);
      const Didact = {
        createElement,
        render,
      };
      // const element = Didect.createElement(
      //   "div",
      //   { id: "foo" },
      //   Didect.createElement("a", null, "bar"),
      //   Didect.createElement("b")
      // );
      // function App(props) {
      //   return <h1>Hi {props.name}</h1>;
      // }
      // const element = <App name="foo" />;
      function App(props) {
        return Didact.createElement("h1", null, "Hi ", props.name);
      }
      const element = Didact.createElement(App, {
        name: "foo",
      });
      const container = document.getElementById("root");
      Didact.render(element, container);
    </script>
  </body>
</html>
