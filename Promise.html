<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
      name="viewport"
    />
    <meta content="ie=edge" http-equiv="X-UA-Compatible" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
       * 在executor抛出一个错误，则该promise的状态是reject
       * 如果在then的onFulfilled和onRejected中return 一个错误，则promise的状态保持不变，是onFulFilled的还是onFulFilled
       * 如果在then中抛出一个错误，则该promise的状态变成rejected
       *
       *
       * 在失败的then中如果没有返回失败的promise 或者 抛出错误，则该promise下一个then将是成功的
       */
      //一个then没有写onRejected ,则相当于写了 reason=>{throw reason}

      //.catch方法的返回值决定了下一个then方法执行那个回调，这和then链式调用的特性一样

      //在then链中返回一个pending状态的promise，则该链式调用会被中间终止
      class MyPromise {
        #state = "pending";
        #value = null;
        #hooksQueue = [];
        constructor(executor) {
          if (typeof executor !== "function") {
            return;
          }
          executor(
            (value) => {
              this.#onState("fulfilled", value);
            },
            (reason) => {
              this.#onState("rejected", reason);
            }
          );
        }

        #onState(state, value) {
          if (this.#state !== "pending") {
            return;
          }
          this.#value = value;
          this.#state = state;
          this.#onHooks();
        }
        #onHooks() {
          let latestPromise = this;
          for (let i = 0; i < this.#hooksQueue.length; i++) {
            const hookAction = this.#hooksQueue[i];
            this.#onHooksResult(hookAction.hook, hookAction.newHook);
          }
        }
        #onHooksResult(hook, newHook) {
          const thenHook =
            this.#state === "fulfilled" ? hook.onFulfilled : hook.onRejected;
          try {
            const hookResult = thenHook ? thenHook(this.#value) : undefined;
            if (hookResult instanceof MyPromise) {
              hookResult.then(...newHook);
            } else {
              newHook.resolve(hookResult);
            }
          } catch (error) {
            newHook.reject(error);
          }
        }

        then(onFulfilled, onRejected) {
          return new MyPromise((resolve, reject) => {
            if (this.#state === "pending") {
              this.#hooksQueue.push({
                hook: { onFulfilled, onRejected },
                newHook: { resolve, reject },
              });
            } else {
              this.#onHooksResult(
                { onFulfilled, onRejected },
                { resolve, reject }
              );
            }
          });
        }
        static resolve() {}
        static reject() {}
        static any() {}
        catch() {}
        all() {}
        race() {}
      }
      const promise = new MyPromise((resolve, reject) => {
        setTimeout(() => {
          resolve("success");
        }, 2000);
      });
      promise
        .then((value) => {
          console.log(1);
          console.log("resolve", value);
        })
        .then((value) => {
          console.log(2);
          console.log("resolve", value);
        })
        .then((value) => {
          console.log(3);
          console.log("resolve", value);
        });
    </script>
  </body>
</html>
