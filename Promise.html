<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
      name="viewport"
    />
    <meta content="ie=edge" http-equiv="X-UA-Compatible" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
       * 在executor抛出一个错误，则该promise的状态是reject
       * 如果在then的onFulfilled和onRejected中return 一个错误，则promise的状态保持不变，是onFulFilled的还是onFulFilled
       * 如果在then中抛出一个错误，则该promise的状态变成rejected
       *
       *
       * 在失败的then中如果没有返回失败的promise 或者 抛出错误，则该promise下一个then将是成功的
       */

      new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("1");
        }, 4000);
      })
        .then((value) => {
          setTimeout(() => {
            return 1;
          }, 1000);
        })
        .then((value) => console.log(value));

      //一个then没有写onRejected ,则相当于写了 reason=>{throw reason}

      //.catch方法的返回值决定了下一个then方法执行那个回调，这和then链式调用的特性一样

      //在then链中返回一个pending状态的promise，则该链式调用会被中间终止
      const p = new Promise((resolve, reject) => {
        resolve(1);
      });
      console.log(p);

      class MyPromise {
        #state = "pending";
        #value = null;
        #hooksQueue = [];
        #onState(state, value) {
          this.#value = value;
          this.#state = state;
          this.#onHooks(state);
        }
        #onHooks(state) {
          let latestPromise = null;
          for (let i = 0; i < this.#hooksQueue.length; i++) {
            const hookAction = this.#hooksQueue[i];
            let thenCallbackHook =
              state === "fulfilled" ? hook.onFulfilled : hook.onRejected;
            try {
              let res = thenCallbackHook();
              if (res instanceof MyPromise) {
                latestPromise = res;
              } else {
                latestPromise = new MyPromise((resolve, _) => {
                  resolve(res);
                });
              }
            } catch (error) {
              latestPromise = new MyPromise((_, reject) => {
                reject(error);
              });
            }
          }
        }
        constructor(executor) {
          if (typeof executor !== Function) {
            return;
          }
          executor(
            (value) => {
              this.#onState("fulfilled", value);
            },
            (reason) => {
              this.#onState("rejected", value);
            }
          );
        }
        then(onFulfilled, onRejected) {
          this.#hooksQueue.push({ onFulfilled, onRejected });
        }
        static resolve() {}

        static reject() {}

        static any() {}

        catch() {}

        all() {}

        race() {}
      }

      const myP = new MyPromise((resolve, reject) => {
        resolve(2);
      });
      console.log(myP);
    </script>
  </body>
</html>
