浏览器刷新操作与缓存
浏览器操作                          强缓存                         协商缓存
在地址栏按回车建                      有效                            有效
页面跳转                              有效                            有效
新开窗口                              有效                            有效
前进、后退                            有效                            有效
浏览器刷新(F5)                        无效                            有效
强制刷新(Ctrl+F5)                     无效                            无效
=========================
强缓存
Expires
  response header 会有一个expires响应头，是一个时间戳，
  接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和expires的时间戳，
  如果本地时间小于expires设定的过期时间，就直接从缓存中获取这个资源。
  这要求本地时间和服务器时间一致




Cache-control
  no-Cache 不设置缓存，走协商缓存
  max-age 缓存时间
  no-store  禁用缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了
  public 表示可以被浏览器和代理服务器缓存，代理服务器一般可用nginx来做
  private 只让客户端可以缓存该资源；代理服务器不缓存
  immutable 
  表示该资源永远不变，但是实际上该资源并不是永远不变，
  它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！
  啥意思？就是说，如果你只设置了cache-control:max-age=31536000,public  
  这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，
  没有过期就从缓存中读取数据；但是有一些 "聪明" 的用户会点击浏览器左上角的刷新按钮去刷新页面，
  这时候就算资源没有过期（1年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了

=============================
协商缓存
Etag 
  etag的优先级比Last-modified高

  response header  
  每个文件有一个，改动文件了就变了，
  就是个文件hash，每个文件唯一，就像用webpack打包的时候，
  每个资源都会有这个东西

if-none-matched 
  文件hash,在request header中
  服务端会比较有无一致的hash



Last-modified 文件的修改时间，精确到秒 response header
if-modified-Since  与Last-modified相同，在request header中


发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。
发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。
